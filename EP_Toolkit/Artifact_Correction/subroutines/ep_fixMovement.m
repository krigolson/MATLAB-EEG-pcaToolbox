function [totmoveTrialNum , outputLog, graphCounter] = ep_fixMovement(inFile, startChunk, endChunk, badDataCriteria, badChans, refChan, butterflyFig, graphCounter, numGraphs, theSubject, eog)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totmoveTrialNum , outputLog, graphCounter] = ep_fixMovement(inFile, startChunk, endChunk, badDataCriteria, badChans, refChan, butterflyFig, graphCounter, numGraphs, theSubject, eog)%%	Reads in file chunks generated by chunkInputFile function.  It runs an ICA on each individual trial%   and drops factors corresponding to large noise sources (usually movement artifact).%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%   badChans:   list of bad channels to exclude from blink detection process.  Will be set to a flat line.%   refChan:    Array of current reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%   eog:        EOG channels.%%   The input chunks are EP format data files.%%Outputs%	totmoveTrialNum: Total list of movement trials.%	Saves files with movement artifact removed, replacing the original chunked files.%   outputLog: output messages from noise fixing process%   graphCounter: the current subplot for the summary figure.%% History:%% by Joseph Dien (5/26/09)% jdien07@mac.com%%  modified 10/28/09 JD%  Added option to disable preprocessing figure for low memory situations.%%  modified 2/11/10 JD%  Will now work with subject average files with multiple subjects.%  MoveTrial no longer initialized to zero.%%  modified 10/12/10 JD%  For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion%  in same fashion as segmented data.%%  modified 10/16/10 JD%  Added support for HEOG saccade correction.%% modified 9/24/13 JD% Restricted blink correction to EEG channels.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Rereference an epoch after performing movement correction% Obtains reference channel info from function call rather than file to make consistent with the other artifact% correction subroutines.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% modified 1/24/17 JD% Excluding EOG channels from the movement correction detection.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~isempty(butterflyFig)    graphCounter=graphCounter+2;end;msg='Fixing movement artifacts.';disp(msg);outputLog{1}=msg;moveTrialNum = [];badChans = badChans(find(badChans));	%drop out bad channels set as being zerooutputLog=[];count=0;theEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;warning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Movement Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;end;for iChunk = startChunk:endChunk    disp([deblank(inFile) '-' num2str(iChunk)]);    eval(['load ''' deblank(inFile) '''-' num2str(iChunk) '.mat']);        if length(dataChunk.facNames) > 1        disp('This function is not intended for application to factor data.');        return    end;        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end;        numChans=length(dataChunk.chanNames);    numSubs=length(dataChunk.subNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    if strcmp(dataChunk.dataType,'continuous')        numTrials=floor(size(dataChunk.data,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch        trialdata=dataChunk.data(:,:,:,theSubject);        trialSize = min(ceil(dataChunk.Fs),size(dataChunk.data,2)); %one second epochs    else        numTrials = length(dataChunk.cellNames);        trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);        trialSize = length(dataChunk.timeNames);    end;        subtractedNoise = zeros(size(trialdata));    moveTrialNum{iChunk}=dataChunk.analysis.moveTrial;    chans = setdiff(EEGchans,badChans);    if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end;    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);    nonEOGchans=find(~ismember(chans,theEOG));    chanMeans=repmat(mean(dataChunk.data(chans,:)')',1,trialSize);        if standAlone        subplot(3,1,1), plot([1:displayPeriod],trialdata(chans,1:displayPeriod));        axis([1 displayPeriod -200 200])        set(gca,'XTickLabel','','XTick',[]);        title([deblank(inFile) '-' num2str(iChunk)],'Interpreter','none');    end;        fprintf('%60s\n',' ' );    for trial =1:numTrials        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Working on ' theSegment '# '], trial, numTrials))        theData=trialdata(chans,(trial-1)*trialSize+1:trial*trialSize)-chanMeans;        if strcmp(dataChunk.dataType,'continuous') && trial == numTrials            theData=trialdata(chans,(trial-1)*trialSize+1:end); %excess time points are tacked onto final epoch        end;        if abs(min(min(theData(nonEOGchans,:))) - max(max(theData(nonEOGchans,:)))) > badDataCriteria.trialminmax %don't bother with PCA if no large amplitude voltages            S = cov(theData); %covariance matrix            if ~any(~diag(S)) %if any time points have zero variance, may not be factorable and definitely not fixable                Sd = diag(sqrt(diag(S)));  %diagonal matrix of standard deviations of variables as used to generate relationship matrix                [V,L] = eig(S);                                V = fliplr(V);                numFac=badDataCriteria.movefacs;                V = V(:,1:numFac);  %truncated eigenvector matrix                FacScr = (theData) * V;    %factor scores, not mean corrected.                ScrDiag = diag(std(FacScr));                A = inv(Sd) * (V * ScrDiag);  %unrotated factor loading matrix                C = sum((A.^2),2)';                A = (diag(sqrt(C).^-1)) * A;  %factor loadings Kaiser-normalized by communalities                [FacPat]= ep_doVarimax(A);                FacPat = diag(sqrt(C)) * FacPat;  %renormalize factor loadings by original communalities                [FacPat, FacCor] = ep_doPromax(FacPat, 3); %Only apply loading weighting to the Varimax step                %to match SAS output and to avoid rounding errors.                FacStr = FacPat * FacCor;	%factor structure matrix (Harman, eq. 12.19, p. 268)                invR=pinv(corrcoef(theData));                FacCof=invR*FacStr;                FacScr=(theData)*FacCof;                FacScr=(FacScr)*inv(diag(std(FacScr)));                                noiseFacs=find(abs(max(abs(Sd*FacPat)).*(max(FacScr(nonEOGchans,:))-min(FacScr(nonEOGchans,:)))) > badDataCriteria.trialminmax);                                if ~isempty(noiseFacs) %if there are noise factors, subtract them out                    FacScrFull = zeros(numChans,numFac);                    for i = 1:length(chans)                        FacScrFull(chans(i),:)=FacScr(i,:);                    end;                    tempVar = zeros(numFac,1);                    tempVar(noiseFacs) = 1;                    noisedata = FacScrFull * (Sd*FacPat* diag(tempVar))';                    if strcmp(dataChunk.dataType,'continuous') && trial == numTrials                        nonoisedata= trialdata(:,(trial-1)*trialSize+1:end) - noisedata;                        trialdata(:,(trial-1)*trialSize+1:end) = nonoisedata;                        subtractedNoise(:,(trial-1)*trialSize+1:end) = noisedata;                    else                        nonoisedata= trialdata(:,(trial-1)*trialSize+1:trial*trialSize) - noisedata;                        trialdata(:,(trial-1)*trialSize+1:trial*trialSize) = nonoisedata;                        subtractedNoise(:,(trial-1)*trialSize+1:trial*trialSize) = noisedata;                    end;                    count=count+1;                    moveTrialNum{iChunk}(trial)=1;                                        %rereference the data.                    if ~isempty(refChan)                        for i = 1:numTrials                            epoch=trialdata(:,(trial-1)*trialSize+1:trial*trialSize);                            referenceData=mean(epoch(refChan,:),1);                            for iChan=1:length(EEGchans)                                theChan=EEGchans(iChan);                                trialdata(theChan,(trial-1)*trialSize+1:trial*trialSize)=epoch(theChan,:)-referenceData;                            end;                        end;                    end;                end;            end;        end    end;    fprintf('%60s\n',' ' );        if count == 1        msg=['1 ' theSegment ' corrected for movement activity.'];    else        msg=[num2str(count) ' ' theSegment 's corrected for movement activity.'];    end    disp(msg);    outputLog{end+1}=msg;        if ~isempty(butterflyFig)        if standAlone            figure(butterflyFig(iChunk));            subplot(3,1,2), plot([1:totalDisplayPeriod],subtractedNoise([badChans; chans],1:totalDisplayPeriod));            title('subtracted movement artifacts','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        subplot(3,1,3), plot([1:totalDisplayPeriod],trialdata([badChans; chans],1:totalDisplayPeriod));            title('with movement artifacts subtracted','Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        else            figure(butterflyFig(iChunk));            theTitle='subtracted movement artifacts';            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedNoise,EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with movement artifacts subtracted';            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end;    end;        if count == 0        msg='No components met threshold so no correction performed.';        disp(msg);        outputLog{end+1}=msg;                if ~isempty(butterflyFig)            if standAlone                figure(butterflyFig(iChunk));                subplot(3,1,2), plot([1:totalDisplayPeriod],ones(1,totalDisplayPeriod));                title('no movements to subtract that were detected','Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                                subplot(3,1,3), plot([1:totalDisplayPeriod],trialdata([badChans; chans],1:totalDisplayPeriod));                title('no movement artifacts subtracted','Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            else                figure(butterflyFig(iChunk));                if numSubs > 1                    theTitle='subtracted movement artifacts';                else                    theTitle='no movements to subtract that were detected';                end;                plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialdata)),EEGchans,theSubject);                subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                                if numSubs > 1                    theTitle='with movement artifacts subtracted';                else                    theTitle='no movement artifacts subtracted';                end;                plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,EEGchans,theSubject);                subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);                title(theTitle,'Interpreter','none');                axis([1 totalDisplayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end;        end;    end;        drawnow        if strcmp(dataChunk.dataType,'continuous')        dataChunk.data(:,:,:,theSubject)=trialdata;    else        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,numChans,trialSize,numTrials);    end;    dataChunk.analysis.moveTrial(theSubject,:)=moveTrialNum{iChunk};        eval (['save ''' inFile '''-' num2str(iChunk) '.mat dataChunk;']);    if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig(iChunk)) ' -djpeg ''' inFile '''-' num2str(iChunk) 'move.jpg']);            else                eval (['print -f' num2str(butterflyFig(iChunk).Number) ' -djpeg ''' inFile '''-' num2str(iChunk) 'move.jpg']);            end;        catch            disp('Couldn''t save a copy of the movement correction figure.  Perhaps your version of Matlab is not current.');        end;    end;end;if standAlone    close(butterflyFig);end;totmoveTrialNum=[];for iChunk = startChunk:endChunk    totmoveTrialNum=[totmoveTrialNum moveTrialNum{iChunk}];end;